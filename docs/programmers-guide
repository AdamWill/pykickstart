

                        pykickstart Programmer's Guide

                               by Chris Lumens

                              January 17, 2007


Introduction
============
pykickstart is a Python library for manipulating kickstart files.  It
contains a common data representation, a parser, and a writer.  This
library aims to be useful for all Python programs that need to work with
kickstart files.  The two most obvious examples are anaconda and
system-config-kickstart.  It is recommended that all other tools that need
to use kickstart files use this library so that we can maintain equivalent
levels of support across all tools.

The kickstart file format itself has only been defined in a rather ad-hoc
manner.  Various documents describe the format, commands, and their
effects.  However, each kickstart-related program implemented its own
parser.  As anaconda added support for new commands and options, other
programs drifted farther and farther out of sync with the "official"
format.  This leads to the problem that valid kickstart files are not
accepted by all programs, or that programs will strip out options it
doesn't understand so that the input and output files do not match.

pykickstart is an effort to correct this.  It was originally designed to
be a common code base for anaconda and system-config-kickstart, so making
the code generic and easily extendable were top priorities.  Another
priority was to formalize the currently recognized grammar in an easily
understood parser so that files that used to work would continue to.  I
believe these goals have been met.

pykickstart also understands all the various versions of the kickstart syntax
that have been around.  Various releases of Red Hat Linux, Red Hat Enterprise
Linux, and Fedora Core have had slightly different versions.  For the most
part, the basic syntax has stayed the same.  However, different commands have
come and gone and different options have been supported on those commands.
pykickstart allows specifying which version of kickstart syntax you want
to support for reading and writing, allowing you to use one code base to
deal with the full range of kickstart files.

This document will cover how to use pykickstart in your programs and how to
extend the basic parser to get customized behavior.  It includes a
description of the important classes and several working examples.


Getting Started
===============
Before diving into the full documentation, it is useful to see an example
of how simple it is to use the default pykickstart in your programs.  Here
is a code snippet that imports the required classes, parses a kickstart
file, and leaves the results in the common data format.

        #!/usr/bin/python
        from pykickstart.parser import *
        from pykickstart.version import makeVersion

        kshandlers = makeVersion()
        ksparser = KickstartParser(ksandlers)
        ksparser.readKickstart("ks.cfg")

The call to makeVersion() creates a new kickstart handler object for the
specified version.  By default, it creates one for the latest supported
syntax version.  The call to KickstartParser() creates a new parser using
the handler object for dealing with individual commands.  The call to
readKickstart() then reads in the kickstart file and sets values in the
handler.

After this call, you don't need ksparser anymore but you will want to hold
on to kshandlers if you are interested in the contents of the file.  If
you want to do some manipulations and then write out the results to a new
file, that's as simple as:

        outfile = open("out.cfg", 'w")
        outfile.write(kshandlers.__str__())
        outfile.close()


Classes
=======
The important classes that make up pykickstart are spread across a handful
of files.  This section includes a brief outline of the contents of those
classes.  For more thorough documentation, refer to the python doc strings
throughout pykickstart.  In python, you can view these docs strings like
so:

        >>> from pykickstart import parser
        >>> help(parser)
        >>> help(parser.KickstartParser)

base.py
-------
This file contains several basic classes that are used throughout the rest
of the library.  For the most part, these are abstract classes that are
not important to most users of pykickstart.  You will really only need to
deal with these classes if you are extending kickstart syntax.  Other
users will mainly only want to look at these classes to see what methods
and attributes are provided.  This information is also available from the
docs strings.

BaseData, BaseHandler, and KickstartCommand are abstract classes that
define common methods and attributes.  These classes may not be used
directly - they can only be used if subclassed.  The BaseData and
KickstartCommand classes are subclassed to create data objects and command
processing objects.  BaseHandler is subclassed to create version handlers
that drive the processing of commands and the setting of data.

DeprecatedCommand is a subclass of KickstartCommand that may be further
used as a subclass for command handler objects.  When one of these
subclasses is used, a warning message is printed.  Commands that are
deprecated are recognized by the parser, but any options given will not be
processed and their use causes a warning message to be printed.

constants.py
------------
This file includes no classes, though it does include several important
constants representing various things in a kickstart handler class.  You
should import its contents like so:

        from pykickstart.constants import *

error.py
--------
This file contains several useful exceptions and methods.  There are four
basic exceptions in pykickstart:  KickstartError, KickstartParseError,
KickstartValueError, and KickstartVersionError.

KickstartError is a generic exception, raised on conditions that are not
appropriate for any of the other more specific exceptions.

If the parser encounters an error while reading your input file, it will
raise a KickstartParseError with the line in question.  Examples of errors
include bad options given to section headers, include files not existing,
or headers given for sections that are not recognized (for instance,
typos).  If the parser encounters an error while processing the arguments
to a command, it will raise a KickstartValueError.  Examples of these
sorts of errors include too many or too few arguments, or missing required
arguments.

KickstartVersionError is only raised by the methods in pykickstart.version
if an invalid version is provided by the user.

Error messages should call the formatErrorMsg function to be properly
formatted before being sent into an exception.  A properly formatted error
message includes the line number in the kickstart file where the problem
occurred and optionally, a more descriptive message.

option.py
---------
This file contains the KSOptionParser and KSOption classes, which are
specialized subclasses of OptionParser and Option from python's optparse
module.  These classes are used extensively throughout the parser and
command handlers.  Specialized subclasses are needed to support required,
deprecated, and versioned options; handle specialized error reporting; and
support additional option types.

parser.py
---------
This file represents the bulk of pykickstart code.  At its core is the
KickstartParser class, which is essentially a state machine.  There is one
state for each of the sections in a kickstart file, plus some specialized
ones to make the parser work.  The readKickstart method is the entry point
into this class and is designed to be as generic as possible.  It reads
from the given filename.  It is also possible that you may want to read
from an existing string, so readKickstartFromString is also provided.

With the exception of _stateMachine, all the methods in KickstartParser
may be overridded in a subclass.  _stateMachine should never be
overridden, however, as it provides the core logic for processing
kickstart files.

There are a few other minor points to note about KickstartParser.  When
creating a KickstartParser object, you can set the followIncludes
attribute to False if you do not wish for include files to be looked up
and parsed as well.  There are several instances when this is handy.  You
can also set the missingIncludesIsFatal attribute to False if you want to
ignore missing include files.  This is most useful when you only care
about the main kickstart file (like in ksvalidator, for instance).  Note
that you can pass None in for kshandlers in the special case if you do not
care about handling any commands at all.  As we will see later, this is
useful in one special case.

The Script class represents a single script found in the kickstart file.
Since there can be several scripts in a single file, all the instances of
Script are stored in a single list.  Somewhat confusingly, this list is
stored in the handler object provided to KickstartParser when it is
instantiated.  The script list is not stored in the parser itself.  There
are three different types of scripts - pre, post, and traceback.  The
script class contains an attribute that may be used to discriminate among
types.

Finally, the parser.py file contains a Packages class for representing the
%packages section of the kickstart file.  It includes three separate lists
- a list of packages to install, a list of packages to exclude, and a list
of groups to install.  It does not contain anything to handle the header
of the %packages section, as this is done by the parser.  The Packages
instance is held in the same place as the script list.

version.py
----------
pykickstart supports processing multiple versions of the kickstart syntax
from the same code base.  In order to make use of this functionality,
users must request objects by version number.  This file provides the
methods and attributes to make this easy.  Versions are specified by
symbolic names that match up with the names of Fedora or Red Hat
Enterprise Linux releases.

There is also a special DEVEL version that maps to the latest supported
syntax version.  All methods in version.py take DEVEL as the implied
version, so most people should never even need to deal with specifying
their own version.

stringToVersion and versionToString map between strings and these symbolic
names.  These are provided to make using pykickstart a little easier.
stringToVersion allows you to take the contents of /etc/redhat-release and
get a pykickstart version right from that.

returnClassForVersion returns the class that matches a specific version.
Most people will not need this capability, as what they are really after
is an instance of that class.  makeVersion returns that instance.


Handler Classes
===============
Kickstart syntax versions are each represented by a file in the handlers/
subdirectory.  For the most part, these are extremely simple files that
define a subclass of the BaseHandler class mentioned above.  The names of
the handler files are important, but this only matters when adding support
for new syntax version.  This will be discussed in a later section.

The control.py file is a little more complicated, however.

control.py
----------
This file contains two dictionaries.  The commandMap defines a mapping
from a syntax version number (as returned by version.stringToVersion) to
another dictionary.  This dictionary defines a mapping from a command
string to an object that processes that command.  Multiple strings may map
to the same object, since some kickstart commands have multiple names
("part" and "partition", for instance).

The dataMap is set up similarly.  It maps syntax version numbers to
further dictionaries.  These dictionaries map data object names to the
objects themselves.  Unlike the commandMap, each name may only map to a
single object.  However, multiple instances of each object can exist at
once as these instances are stored in lists.  This entire setup is
required to handle the data for commands such as "network" and "logvol",
which can be specified several times in one kickstart file.

The structures in control.py look to be much more verbose than required.
Since much data is duplicated among all the various substructures, it
seems like this is a perfect place for better object oriented design.
However, the duplication is considered a benefit in this one case.  It can
be difficult to tell which commands are supported by each syntax version,
and what object handles those commands.  The verbosity in this file makes
it very clear exactly which objects will be used by each version of
kickstart.


Command Classes
===============
In the commands/ subdirectory you will see many files.  Each file
corresponds to a single kickstart command.  At a minimum, one file will
contain a single class that implements the parser, writer, and data store
for that command.  This command is then entered into the appropriate place
in the commandDict from control.py, and then called in the right places by
the parser.

These files may be slightly more complicated, however.  Some files contain
several classes that all do the same thing.  This is because there have
been multiple versions of the syntax for that command, and there is one
class per version.  They are all grouped in the same file for ease of
readability, and later versions are allowed to inherit from earlier
versions by means of subclassing.

Each file may also contain one or more data objects.  These data objects
are the same as the contents of the dataDict from control.py.  There may
also be several versions of each data object.

At a minimum, the command classes and data classes must implement the
methods from KickstartCommand and BaseData.  In particular, __init__,
__str__, and parse will be called by the KickstartParser.  An exception
will be raised if one is not defined and the abstract class's method is
called instead.




*** EVERYTHING UNDER HERE IS CURRENTLY OUT OF DATE AND SLOWLY BEING
*** REWRITTEN.

Extending pykickstart
=====================
By default, pykickstart reads in a kickstart file and sets values in a
KickstartData object.  This is useful for some applications, but not all.
anaconda in particular has some odd requirements for kickstart so it will
be our basis for examples on extending pykickstart.

Only paying attention to one command
------------------------------------
Sometimes, you only want to take action on a single kickstart command and
don't care about any of the others.  anaconda, for instance, supports a
vnc command that needs to be processed well before any of the other
commands.  Remember from earlier that any command mapping to None in the
handlers is skipped.  That makes this fairly easy, then.  All we need to
do is make a specialized KickstartHandlers subclass and hook this into a
regular parser:

	from pykickstart.data import *
	from pykickstart.parser import *

	class VNCHandlers(KickstartHandlers):
		def __init__ (self, ksdata):
			KickstartHandlers.__init__(self, ksdata)
			self.resetHandlers()
			self.handlers["vnc"] = self.doVnc

	ksdata = KickstartData()
	kshandlers = VNCHandlers(ksdata)
	ksparser = KickstartParser(ksdata, kshandlers)
	ksparser.readKickstart("ks.cfg")

Here, we make use of the KickstartHandlers.resetHandlers method.  This
method blanks out every entry in the handlers dictionary.  We then set the
vnc command handler to the default value, which you can easily get from
checking out the pykickstart source.  Then, make an instance of our new
class and pass this to KickstartParser().  When readKickstart is called,
the file will be parsed as usual but only the vnc command will ever be
handled.

You can then check the results by examining ksdata.vnc.

Customized handlers
-------------------
In other cases, you may want to include some customized behavior in your
kickstart handlers.  In this case, you'll still want to create a subclass
of KickstartHandlers, though you will need to make sure your handler calls
the superclass still.

	from pykickstart.data import *
	from pykickstart.parser import *

	class KSHandlers(KickstartHandlers):
		def doBootloader (self, args):
			KickstartHandlers.doBootloader(self, args)
			print "bootloader location = %s" % self.ksdata.bootloader["location"]

	ksdata = KickstartData()
	kshandlers = VNCHandlers(ksdata)
	ksparser = KickstartParser(ksdata, kshandlers)
	ksparser.readKickstart("ks.cfg")

This example is very simple, but you can still see what would be required
for complex cases.  Your handler needs to accept an args argument, which
is a list of arguments provided to the command.  Then, make sure to call
the superclass's method of the same name to set the KickstartData.
Finally, do your specialized behavior.

It is even possible to force your handlers to accept more arguments,
though it is slightly more complicated.  This requires making a subclass
of KickstartParser in addition to KickstartHandlers.

	from pykickstart.data import *
	from pykickstart.parser import *

	class KSHandlers(KickstartHandlers):
		def doBootloader (self, userarg, args):
			KickstartHandlers.doBootloader(self, args)
			print "%s bootloader location = %s" % (userarg, self.ksdata.bootloader["location"])

		...

	class KSParser(KickstartParser):
		def __init__ (self, ksdata, kshandlers, userarg):
			self.userarg = userarg
			KickstartParser.__init__(self, ksdata, kshandlers)

		def handleCommand (self, cmd, args):
			if not self.handler:
				return

			if not self.handler.handlers.has_key(cmd):
				raise KickstartParseError, (cmd + " " + string.join(args))
			else:
				if self.handler.handlers[cmd] != None:
					self.handler.currentCmd = cmd
					self.handler.handlers[cmd](self.userarg,
args)

	ksdata = KickstartData()
	kshandlers = VNCHandlers(ksdata)
	ksparser = KSParser(ksdata, kshandlers, "note: ")
	ksparser.readKickstart("ks.cfg")

Let's examine this example a little more closely.  First, you need to
create a subclass of KickstartParser whose __init__ method stores your
argument.  Then you also need to override handleCommand.  In the
overridden method, the only difference is that on the last line you'll
need to pass your argument.

In your subclassed KickstartHandlers, you will need to make sure every
handler accepts your new argument.  You could possibly get around this
requirement by further modifying handleCommand to strip off your argument
for commands that do not accept it.  However, I'm not demonstrating that
here.  Then, make sure to call the superclass's handler method without any
additional arguments.

Adding a new command
--------------------
Adding support for a new command is fairly straightforward.  You'll need
to create a KickstartHandlers and KickstartWriter subclass and add your
methods to the handler lists.

	from pykickstart.data import *
	from pykickstart.parser import *
	from pykickstart.writer import *

	class SpecialHandlers(KickstartHandlers):
		def __init__ (self, ksdata):
			KickstartHandlers.__init__(self, ksdata)
			self.handlers["log"] = self.doLog

		def doLog (self, args):
			op = KSOptionParser()
			op.add_option("--level", dest="level")
			op.add_option("--host", dest="host")

			(opts, extra) = op.parse_args(args=args)

			self.ksdata.log["level"] = getattr(opts, "level")
			self.ksdata.log["host"] = getattr(opts, "host")

	class SpecialWriter(KickstartWriter):
		def __init__ (self, ksdata):
			KickstartWriter.__init__(self, ksdata)
			self.handlers.insert(1, self.doLog)

		def doLog(self):
			argstr = ""

			if self.ksdata.log["level"]:
				argstr = "--level=%s" % self.ksdata.log["level"]
			if self.ksdata.log["host"]:
				argstr = argstr + "--host=%s" % self.ksdata.log["host"]

			if argstr != "":
				return "log %s" % argstr
			else
				return

	ksdata = KickstartData()
	kshandlers = SpecialHandlers(ksdata)
	ksparser = KickstartParser(ksdata, kshandlers)
	ksparser.readKickstart("ks.cfg")

This is all fairly straightforward, with the possible exception of the
OptionParser stuff.  Without getting into it too much, you'll need to
create a new instance of KSOptionParser, and then use the Python
documentation on how to use it.  It's a very complex, powerful class.
Make sure to set the KickstartData afterwards.

The KickstartWriter object is also pretty simple.  Make sure your method
returns an empty string if there's nothing set on this option, and the
appropriate string otherwise.

Adding a new section
--------------------
Currently, there is no simple way to add a new section.  This requires
adding more code to readKickstart as well as additional states.
readKickstart is not set up to do this sort of thing easily.
